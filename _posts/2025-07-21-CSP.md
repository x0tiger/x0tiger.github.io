---
published: true
title: Content Security Policy
date: 2025-07-21 07:42:00 +0200
categories: Security
tags:
  - Security
---



# Content Security Policy (CSP)

Imagine your web page is like a house, and Content Security Policy (CSP) is the guard standing at its gate. Its main job is to define who's allowed to enter the house (your web page) and who's not, and what they're allowed to do inside. This protects your page from any strange or suspicious characters trying to break in or mess things up.

---

## So, what exactly is CSP?

Simply put, it's a mechanism that defines which resources your web page is allowed to fetch or execute. These resources can be images, frames, JavaScript code, or anything else. CSP sets a list of trusted paths and sources, and the browser adheres to this list, actively blocking any detected violations.

---

## How is CSP implemented?

It's implemented in two main ways:

### Via the Response Header from the server:

This is like the server sending a message to the guard saying:  
"Listen up, chief, only stuff coming from 'self' (the same origin) or images from 'allowed-website.com' are allowed through."

```http
Content-Security-Policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
````

### Or via the Meta Tag in the HTML page's code:

This is placed directly inside your page's HTML, like writing instructions for the guard on a sign at the house's entrance:

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```

As soon as the browser receives this policy, it adheres to it and actively blocks violations as they are detected.

---

## How Does CSP Work?

CSP works by restricting the origins from which active and passive content can be loaded. It can also restrict certain aspects of active content, such as the execution of inline JavaScript, and the use of eval().

---

## CSP Directives

These directives are the rules that set the resource loading policy. Each directive controls a specific type of resource:

- **script-src:** Specifies allowed sources for JavaScript. This includes not only URLs loaded directly into `<script>` elements but also things like inline script event handlers (such as onclick) and XSLT stylesheets which can trigger script execution.
    
- **default-src:** Defines the default policy for fetching resources. When fetch directives are absent in the CSP header, the browser follows this directive by default. However, some directives don't follow default-src, such as:
    
    - base-uri
        
    - form-action
        
    - frame-ancestors
        
    - plugin-types
        
    - report-uri
        
    - sandbox
        
- **child-src:** Defines valid sources for web workers and nested Browse contexts loaded using elements such as `<frame>` and `<iframe>`.
    
- **connect-src:** Restricts URLs for loading using interfaces such as `<a>`, fetch, websocket, and XMLHttpRequest.
    
- **frame-src:** Specifies valid sources for nested Browse contexts loading using elements such as `<frame>` and `<iframe>`.
    
- **frame-ancestors:** Specifies sources that can embed the current page. This directive applies to `<frame>`, `<iframe>`, `<object>`, `<embed>`, and `<applet>` tags. It's important to know that this directive can't be used in `<meta>` tags and applies only to non-HTML resources.
    
- **img-src:** Defines allowed sources for loading images on the web page.
    
- **manifest-src:** Defines allowed sources of application manifest files.
    
- **media-src:** Defines allowed sources from where media objects such as `<audio>`, `<video>` and `<track>` can be loaded.
    
- **object-src:** Defines allowed sources for the `<object>`, `<embed>` and `<applet>` elements.
    
- **base-uri:** Defines allowed URLs that can be loaded using the `<base>` element.
    
- **form-action:** Lists valid endpoints for submission from `<form>` tags. Whether form-action should block redirects after a form submission is debated, and browser implementations of this aspect are inconsistent (e.g., Firefox 57 doesn't block redirects, whereas Chrome 63 does).
    
- **plugin-types:** Restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded. Instantiation of an `<embed>`, `<object>` or `<applet>` elements will fail if:
    
    - the element to load doesn't declare a valid MIME-type
        
    - the declared type doesn't match one of the specified types in the plugin-types directive
        
    - the fetched resource doesn't match the declared type
        
- **upgrade-insecure-requests:** Instructs browsers to rewrite URL schemes, changing HTTP to HTTPS. This directive can be useful for websites with large numbers of old URLs that need to be rewritten.
    
- **sandbox:** Enables a sandbox for the requested resource similar to the `<iframe>` sandbox attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.
    

For more information on all directives, you can check out:  
[MDN Web Docs: Content-Security-Policy - Directives](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#directives).

---

## Source Values

These values are used to define the directives' values:

- `*`: Allows any URL except data:, blob:, and filesystem:. So, "anything but these."
    
- `<host-source>`: An internet host by name or IP address. The URL scheme, port number, and path are optional. Wildcards * can be used for subdomains, host addresses, and port numbers, indicating that all legal values of each are valid.
    
- `<scheme-source>`: A scheme such as http: or https: (the colon : is required). Data schemes can also be specified:
    
    - `data:` Allows data: URLs to be used as a content source.
        
    - `mediastream:` Allows mediastream: URIs to be used as a content source.
        
    - `blob:` Allows blob: URIs to be used as a content source.
        
    - `filesystem:` Allows filesystem: URIs to be used as a content source.
        
- `'self'`: Refers to the origin from which the protected document is being served, including the same URL scheme and port number. Meaning, "from the same place I am."
    
- `'unsafe-eval'`: Allows the use of eval() and other unsafe methods for creating code from strings. This is risky and can lead to security issues.
    
- `'unsafe-hashes'`: Allows enabling specific inline event handlers.
    
- `'unsafe-inline'`: Allows the use of inline resources, such as inline `<script>` elements, javascript: URLs, inline event handlers, and inline `<style>` elements. This is also risky.
    
- `'none'`: Refers to the empty set; that is, no URLs match. "Nothing at all."
    
- `nonce-<base64-value>`: An allowlist for specific inline scripts using a cryptographic nonce (number used once). The server must generate a unique nonce value each time it transmits a policy.
    
- `<hash-algorithm>-<base64-value>`: A sha256, sha384, or sha512 hash of scripts or styles. This value consists of the algorithm used to create the hash followed by a hyphen and the base64-encoded hash of the script or style.
    

For the full list of directive sources, you can check here:  
[MDN Web Docs: Content-Security-Policy - CSP source values](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#source_list_values).

---

## Example to Illustrate This

Let's look at this example to understand better:

```http
Content-Security-Policy: default-src 'self'; script-src https://website.com;
```

### What will pass and what won't?

- This image will be allowed because it's loading from the same domain (website.com), and img-src isn't specified, so it defaults to default-src which is 'self':
    

```html
<img src="assets/images/logo.png">
```

- This script will be allowed because it's loading from the same domain (website.com), which is explicitly permitted in script-src:
    

```html
<script src="assets/scripts/main.js"></script>
```

- This script will NOT be allowed because it's trying to load from an undefined domain (attacker-website.com), and script-src only allows [https://website.com](https://website.com/):
    

```html
<script src=https://attacker-website.com/hook.js></script>
```

- This payload will NOT be allowed because inline scripts (code written directly in HTML) are blocked by default in CSP if 'unsafe-inline' is not permitted:
    

```html
"/><script>alert(1337)</script>
```

- This image will NOT be allowed because it's loading from an undefined domain (attacker-website.com), and since img-src isn't defined, it takes the value of default-src which is 'self' only:
    

```html
<img src="https://attacker-website.com/image.svg">
```

---

## CSP Bypassing Techniques

Now, here's where it gets critical! If CSP isn't configured correctly, vulnerabilities can open up for attackers to bypass this protection. There are online tools you can use to check CSP:

- [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com/)
    
- [https://cspvalidator.org/](https://cspvalidator.org/)
    

Let's look at some common techniques:

---

### Allowed CDNs

If script-src or object-src allows a public CDN by its domain name, there might be a risk. Why? Because any data from that CDN could be accessed, including vulnerable libraries or frameworks.

If 'unsafe-eval' or 'unsafe-inline' are also allowed in script-src, this significantly simplifies the exploitation of a vulnerable library or framework, as you can directly call the vulnerable component. Otherwise, you'd need to find a way to call that component.

Example: This CSP allows [https://cdnjs.cloudflare.com](https://cdnjs.cloudflare.com/) and also sets 'unsafe-eval' in script-src. This allows using AngularJS to execute arbitrary JavaScript code:

```html
<head>
    <meta http-equiv="Content-Security-Policy" content="script-src 'unsafe-eval' https://cdnjs.cloudflare.com;">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js"></script>
</head>
<body>
    <div ng-app ng-csp>{{$on.constructor('alert(1)')()}}</div>
</body>
```

**Explanation of the Risk:** If the CDN hosts old or known vulnerable versions of libraries, and an attacker can exploit that vulnerability, they can execute their code. The 'unsafe-eval' property allows direct code execution, instead of complex code execution methods.

---

### Allowed Domains that Host User Content

If script-src or object-src allows a domain where anyone can host arbitrary content, an attacker might be able to upload a malicious script and execute it.

Example: This CSP allows [https://storage.googleapis.com](https://storage.googleapis.com/) in script-src. This makes it possible for an attacker to upload a payload to GCP Cloud Storage and achieve arbitrary JavaScript execution.

```html
<head>
    <meta http-equiv="Content-Security-Policy" content="script-src https://storage.googleapis.com;">
</head>
<body>
    <script src=https://storage.googleapis.com/path/to/malicious/script.js></script>
</body>
```

**Explanation of the Risk:** Any cloud storage or hosting service that allows file uploads and direct linking via `<script src>` can be exploited if the CSP allows its domain. The attacker uploads a malicious JS file to this service, then forces the browser to load and execute it.

---

### data: Scheme

If default-src, script-src, frame-src or object-src allows the data: scheme, it's possible to execute arbitrary JavaScript code by injecting a tag.

```html
<head>
    <meta http-equiv="Content-Security-Policy" content="script-src data:;">
</head>
<body>
    <script src=data:text/javascript,alert(1)></script>
    <iframe src='data:text/html,<script defer="true" src="data:text/javascript,alert(1)"></script>'></iframe>
    <iframe srcdoc='<script src="data:text/javascript,alert(1)"></script>'></iframe>
    <object data="javascript:alert(1)">
</body>
```

**Explanation of the Risk:** Using a data: URI allows developers to embed data directly into HTML files, like images or code. If the CSP doesn't block data: in script-src or frame-src, an attacker can inject JavaScript code encoded as a data: URI and execute it.

---

### JSONP

JSONP APIs work with the callback= parameter, which specifies a function to process the data sent along with it. If there's no function name validation in JSONP, it's possible to inject a custom callback function and execute arbitrary JavaScript code.

JSONP APIs can be used to bypass a Content Security Policy. For example, the following CSP allows script loading from [https://accounts.google.com](https://accounts.google.com/). Since [https://accounts.google.com](https://accounts.google.com/) hosts JSONP endpoints, they can be used to execute arbitrary code.

```html
<head>
    <meta http-equiv="Content-Security-Policy" content="script-src https://accounts.google.com;">
</head>
<body>
    <script src="https://accounts.google.com/o/oauth2/revoke?callback=alert(1)"></script>
</body>
```

This exploitation doesn't require unsafe-inline because the JSONP response handler script must be allowed in the CSP to serve legitimate requests.

References:

- JSONBee: Contains ready-to-use JSONP endpoints on different websites.
    

---

### Allowed microsoft.com in script-src

It's possible to bypass a CSP if it allows microsoft.com in script-src due to a CSP bypass found in WordPress.

```html
<head>
    <meta http-equiv=Content-Security-Policy content="script-src https://www.microsoft.com;">
</head>
<body>
    <script src=https://www.microsoft.com/en-us/research/wp-json?_jsonp=alert></script>
</body>
```

References:

- Bypass CSP Using WordPress By Abusing Same Origin Method Execution
    

---

### Missing or Misconfigured base-uri

If the **base-uri** directive is missing or misconfigured, attackers might be able to use a base tag injection attack. This can manipulate the URLs of relative links and forms on the page, potentially leading to redirecting users to malicious pages or stealing data.

Example attack scenario:

If a page allows an attacker to inject a `<base href="https://malicious-site.com/">` tag and no **base-uri** directive restricts this, the browser will interpret relative URLs on the page as relative to the malicious site, possibly causing scripts or resources to be loaded from attacker-controlled origins.

---

## How to Test and Harden Your CSP?

1. **Use CSP Evaluators:** Tools like Google's CSP Evaluator ([https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com/)) help analyze your CSP header and point out risky configurations.
    
2. **Avoid 'unsafe-inline' and 'unsafe-eval':** These allow dangerous inline script execution and dynamic code evaluation.
    
3. **Use Nonces or Hashes:** For inline scripts that must be used, employ cryptographic nonces or hashes to whitelist them explicitly.
    
4. **Limit Trusted Domains:** Only allow necessary domains for scripts, styles, images, etc.
    
5. **Use Report-Only Mode:** Start by using the `Content-Security-Policy-Report-Only` header to monitor violations without blocking them, to avoid breaking legitimate functionality.
    
6. **Regularly Review and Update:** As your site evolves, update CSP accordingly, and stay informed on CSP bypass techniques.
    

---

## Conclusion

Content Security Policy is a powerful and essential security feature that acts as a trusted guard for your website, defining exactly what can be loaded and executed. When configured properly, it drastically reduces the risk of Cross-Site Scripting (XSS) and other code injection attacks.

However, an improperly configured CSP can be bypassed by attackers exploiting allowed unsafe sources or poorly controlled directives. Therefore, understanding CSP directives and source values deeply, and carefully crafting your policy is crucial.

---

## References and Resources

- [MDN Web Docs: Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)
    
- [Google CSP Evaluator](https://csp-evaluator.withgoogle.com/)
    
- [CSP Validator](https://cspvalidator.org/)
    
- [JSONBee - JSONP endpoints list](https://github.com/hayd/json-bee)
    
- [Bypass CSP Using WordPress](https://portswigger.net/research/content-security-policy-bypass-using-wordpress)
    
- [OWASP CSP Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)
    

---

